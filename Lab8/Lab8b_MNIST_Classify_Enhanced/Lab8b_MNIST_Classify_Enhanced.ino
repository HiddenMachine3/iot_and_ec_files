#include <time.h>
#include <EloquentTinyML.h>

// This file has the TFlite model generated by the Cars_Classify_Tflite_hex.ipynb 
// In the directory: G:\Users\Mouli\IIITL\AI-for-IoT\PresentationMaterials\SampleProgs\Keras\classify\cars
// Done on 7 Apr 2021
// sine_model.h contains the array you exported from the previous step with xxd or tinymlgen
#include "MNIST_model_esp32_new.h"
#include "MNIST_x_test0_data_new.h"
#include "MNIST_x_train0_data_new.h"

#define NUMBER_OF_INPUTS 784 
#define NUMBER_OF_OUTPUTS 10 

// in future projects you may need to tweek this value: it's a trial and error process
// When 5 * 1024 was given it gave error, which can be seen by giving a reset to the board and checking the error messages
// while the model is getting created (ml.begin function call in setup)
// When you notice that the output values of the TFLite model are all zero, you should suspect that Arena size given is not enough
#define TENSOR_ARENA_SIZE 6*1024  // Since the size of TFLite model is around 104704 half of that is given as Arena size

Eloquent::TinyML::TfLite<NUMBER_OF_INPUTS, NUMBER_OF_OUTPUTS, TENSOR_ARENA_SIZE> ml;

void setup() {
    Serial.begin(115200);
    
    ml.begin(MNIST_model_esp32_new);
}

float y_pred[NUMBER_OF_OUTPUTS] = {0};
float fRes = NULL;
int y_test0 = 7;
int y_train0 = 5;

void loop() {
    uint32_t startTime;
    uint32_t timeIt;
    int num = 0;
    initfResult(y_pred);

    startTime = micros();
    fRes = ml.predict(x_train0, y_pred);
    timeIt = micros() - startTime;
    
    Serial.print("Train0 took ");
    Serial.print(timeIt);
    Serial.println(" micros to run inference");
    
    Serial.print("\nThe output value returned for x_train0 is:\n");
    Serial.println(fRes);
    displayOutput(y_pred);
    
    num = getMaxIndex(y_pred);
    Serial.print("\nThe x_train0 image contains the number ");
    Serial.println(num);

    Serial.print("x_train0: The predicted number/class is: ");
    Serial.println(ml.probaToClass(y_pred));
    Serial.print("Sanity check: ");
    Serial.println(ml.predictClass(x_train0));

    startTime = micros();
    fRes = ml.predict(x_test0, y_pred);
    timeIt = micros() - startTime;
    
    Serial.print("Train0 took ");
    Serial.print(timeIt);
    Serial.println(" micros to run inference");

    Serial.print("\nThe output value returned for x_test0 is:\n");
    Serial.println(fRes);
    displayOutput(y_pred);

    num = getMaxIndex(y_pred);
    Serial.print("\nThe x_test0 image contains the number ");
    Serial.println(num);

    Serial.print("x_test0: The predicted number/class is: ");
    Serial.println(ml.probaToClass(y_pred));
    Serial.print("Sanity check: ");
    Serial.println(ml.predictClass(x_test0));

    Serial.print("Test0 took ");
    Serial.print(timeIt);
    Serial.println(" micros to run inference");    

    delay(3000); // 3 seconds of delay between two plots
}

void initfResult(float *fResult){
  
    for(int i = 0; i < NUMBER_OF_OUTPUTS; i++){
       fResult[i] = 0.0f;
    }
} // end of displayOutput()

void displayOutput(float *fResult){
  
    for(int i = 0; i < NUMBER_OF_OUTPUTS; i++){
        Serial.print(fResult[i]);
        Serial.print(" ");
    }
} // end of displayOutput()

int getMaxIndex(float *valArr){
    byte maxIndex = 0;
    float maxValue = valArr[maxIndex];
    
    for(byte i = 1; i < NUMBER_OF_OUTPUTS; i++)
    {
        if(valArr[i] > maxValue) {
            maxValue = valArr[i];
            maxIndex = i;
        }
    }

    return maxIndex;
    
} // getMaxIndex()
